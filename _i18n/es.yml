? '## First Public Release of the Godot Synth Plugin We are excited to announce the
  first public release of the [Godot Synth](https://eclipsinglines.github.io/GodotSynth/)
  plugin! This powerful tool is designed to enhance your game development experience
  by providing versatile sound synthesis capabilities directly within the Godot Engine.
  ### How to Get It You can download the plugin from the following sources: - [Godot
  Asset Library](https://godotengine.org/asset-library/asset/3839) - Directly from
  our [repository on GitHub](https://github.com/EclipsingLines/GodotSynth/releases)
  Get started with creating immersive soundscapes and elevate your projects with Godot
  Synth!'
: '## Primer Lanzamiento Público del Plugin Godot Synth ¡Nos complace anunciar el
  primer lanzamiento público del plugin [Godot Synth](https://eclipsinglines.github.io/GodotSynth/)!
  Esta poderosa herramienta está diseñada para mejorar tu experiencia de desarrollo
  de juegos al proporcionar capacidades versátiles de síntesis de sonido directamente
  dentro del motor Godot. ### Cómo Obtenerlo Puedes descargar el plugin desde las
  siguientes fuentes: - [Biblioteca de Assets de Godot](https://godotengine.org/asset-library/asset/3839)
  - Directamente desde nuestro [repositorio en GitHub](https://github.com/EclipsingLines/GodotSynth/releases)
  ¡Comienza a crear paisajes sonoros inmersivos y eleva tus proyectos con Godot Synth!

  '
? '## Overview A few days ago I finished the first version of my synthesizer plugin
  for Godot. This project is meant now to become a full set of features for game developers
  and sound designers to create, modify, modulate and perform sounds in game in a
  programmer friendly and efficient way. ## Project Start For valentine''s day in
  2025 I decided to make my partner an app. She''s always liked flowers, so I made
  a small Godot mobile game where you procedurally grow a flower, the game has a simple
  day/night cycle and a procedural music system. And if you think that I have used
  the word procedural too many times, it is because I wanted to make all the content
  for her app during runtime. So I made a few algorithms, learned how to use LLMs
  for game development (a process which is still ongoing) and made an android build
  to test. To my surprise, the flower looked kinda nice from my very first attempt
  and the whole system seemed to run at a very respectable frame rate (for a GDScript
  running on an old Pixel phone) until the first procedurally generated music note
  started playing, which dropped my frame rate to about 5~6 fps and made my game unplayable.
  ## GDScript vs C++ At that point I only had a few hours to deliver my project in
  time, as missing Valentine''s Day would mean I should wait a year to deliver the
  project and also that I would have nothing of mine to give. So I hacked a solution
  where I played very small short notes from my synth and then would use expansive
  reverbs and long delays to fake longer sounds. This got me to an acceptable performance
  for my project but left an itch at the back of my mind, the core idea of procedurally
  generating the sounds was very good and worked really well for the game ambiance,
  and I knew that this was the way I wanted to compose music for my next games. So
  I started looking into how to optimize the sound system I had made initially and
  the obvious answer was implementing it as a GDExtension plugin. According to DeepSeek,
  moving my sound generation algorithm to C++ could make a 100x improvement in performance,
  so I decided to do it. ## Plaits To be completely honest, this was not the first
  time I tried something like this either, I love using VCV Rack and would consider
  it my main DAW. I am a big fan of the SurgeXT series of audio plugins, and their
  implementation in VCV is just outstanding. SurgeXT provides extensive modulation
  capabilities with very easy to follow visual aids to showcase what the modulation
  is actually doing. I am also a big fan of Emilie Gillet and her open source contributions
  to electronic music, I don''t think I am exaggerating when I say that she''s probably
  the most influential audio developer of our generation. This brings me to [Plaits](https://pichenettes.github.io/mutable-instruments-documentation/modules/plaits/downloads/plaits_quickstart.pdf).
  > Plaits is a digital voltage-controlled sound source capable of sixteen different
  synthesis techniques. Plaits reclaims the land between all the fragmented islands
  of sound produced by its predecessor, Braids For those of you who don''t know, Plaits
  is a macro oscillator sound module by Mutable Instruments with several different
  sound engines and 4 large knobs on the front to control: - Frequency - Harmonics
  - Timbre - Morph And with these 4 simple controllers, the module is able to tame
  some oscillation algorithms that are usually very difficult to manage, like granular
  formant or FM synthesis. This gives users an immense sound palette and makes the
  module extremely flexible, allowing users to do percussions, leads, pads chords
  and a lot more with a simple but efficient setup. ## First attempt The [source code](https://github.com/pichenettes/eurorack/tree/master/plaits)
  for it is also MIT license, so my first idea was to simply bring Plaits into Godot.
  So back in November, I made a repository and named it Glaits, watched a bunch of
  tutorials on how to create C++ extensions for Godot and got up to the point where
  I could compile the project with the imported Plaits submodules, but these were
  never meant to run on the same environment as a game engine. These were also extremely
  heavily optimized algorithms, which meant that some critical steps of the code were
  actually written in assembler, which the Godot compiler was having a lot of trouble
  figuring out. This put a instant brake into my project just after a week of development
  and I decided to leave it there. ## Second Attempt After taking a break from the
  initial attempt with Glaits, I decided to approach the problem from a different
  angle. Instead of directly porting the entire Plaits module into Godot, I would
  focus on creating a lightweight version that encapsulated the core functionalities
  I wanted to implement in my synthesizer plugin. ### Research and Redesign I revisited
  the functionalities of Plaits and identified the key synthesis techniques that would
  be most useful for game development. These included: - **Basic Waveforms**: Sine,
  Square, Sawtooth, and Triangle. - **FM Synthesis**: For more complex harmonic content.
  - **Granular Synthesis**: To create evolving textures and soundscapes. - **Formant**:
  To create speech sounding audio. - **Noise Generation**: Useful for percussive sounds
  and effects. With these elements in mind, I designed a simplified architecture for
  my synthesizer plugin. This would consist of modular components that could be easily
  combined and controlled in real-time through Godot’s scripting system. ### Implementation
  Steps 1. **Setting Up the GDExtension Framework**: - I created a new GDExtension
  project within Godot 4.x. - Followed guidelines on setting up C++ bindings to expose
  my synthesizer functions to GDScript. 2. **Core Sound Engine Development**: - Implemented
  basic waveforms using C++, ensuring they were optimized for performance. - Developed
  an FM synthesis module, allowing users to adjust frequency modulation parameters
  dynamically. - Created a formant engine for voice synthesis. 3. **Modulation System**:
  - Added modulation options for the most important parameters. 4. **User Interface
  Components**: - Integrated custom UI components in Godot that allow users to interact
  with the synthesizer easily. - Used Control nodes to create sliders, knobs, and
  buttons representing each parameter of the sound engine. 5. **Testing and Optimization**:
  - Conducted extensive testing on various devices (including lower-end Android phones)
  to ensure performance remained high even with multiple instances running simultaneously.
  ### Early Results After a week of development on this using AI powered development
  tools I had made a lot of progress and had a setup with 3 oscillator engines with
  different modulation parameters and support for saving presets by using a Sound
  Configuration custom resource. In this early and naive iteration the sound configuration
  was in charge of almost everything, as it would create an appropriate engine to
  produce the sound, create the audio bus specifically for this sound, create the
  audio effects defined in the audio effect array. The modulations were also hardcoded
  into the variables they were controlling which started showing some synchronization
  issues when some modulations were running at a faster pace than others. ### Buffer
  issues The last straw came when trying to create a modulated effect. Like I explained
  the effects were handled by the audio bus itself, which meant that the Godot internal
  audio server was in charge of the timings and the buffer which created a few issues
  with my plan. Mainly, my modulations to the sound generators were applied on a **per-sample**
  basis, ensuring high resolution on the modulators, but I could only modulate the
  effects on a **per-buffer** basis, causing some unexpected sound artifacts and even
  more desynchronization. At this point, even with all the progress I had made, I
  was feeling hopeless about my project until I had the idea of the note context.
  ## Note context The idea was simple: to pass a context data structure that the user
  could use to manipulate the sound generation without directly controlling the engines.
  It contains data about the current frequency, velocity and also keeps track of the
  current note duration. This same lightweight structure then gets passed around the
  oscillators, modulation sources and effects in order to obtain updated audio buffers.
  This new approach was very promising but required a complete rework of my system,
  so I deleted everything and started again from scratch. Starting this way also allowed
  for the creation of the modulated parameter, which can define a float base value
  that can be modulated by any source. And with this last element the core of my synthesizer
  was complete. ## Conclusion Developing this project was a very rewarding and interesting
  adventure. It pushed me to my own limits of what I knew about C++, forced me to
  learn new tools and frameworks, and challenged me to actually finish and publish
  something. This post is long enough as it is right now, I''ll make some more other
  post later explaining the architecture and the choices made in more detail and will
  also start a small tutorial on how to effectively use LLMs with Godot.'
: '## Resumen Hace unos días terminé la primera versión de mi plugin de sintetizador
  para Godot. El objetivo de este proyecto es convertirse en un conjunto completo
  de características para que los desarrolladores de juegos y los diseñadores de sonido
  creen, modifiquen, modulen e interpreten sonidos en el juego de una manera eficiente
  y amigable para los programadores. ## Inicio del proyecto Para el día de San Valentín
  de 2025, decidí hacerle una aplicación a mi pareja. A ella siempre le han gustado
  las flores, así que hice un pequeño juego móvil de Godot donde cultivas una flor
  de forma procedural. El juego tiene un ciclo simple de día/noche y un sistema de
  música procedural. Y si crees que he usado la palabra procedural demasiadas veces,
  es porque quería crear todo el contenido para su aplicación durante el tiempo de
  ejecución. Así que hice algunos algoritmos, aprendí a usar LLM para el desarrollo
  de juegos (un proceso que aún está en curso) e hice una compilación para Android
  para probar. Para mi sorpresa, la flor se veía bastante bien desde mi primer intento
  y todo el sistema parecía ejecutarse a una velocidad de fotogramas muy respetable
  (para un GDScript que se ejecuta en un teléfono Pixel antiguo) hasta que comenzó
  a sonar la primera nota musical generada procedimentalmente, lo que redujo mi velocidad
  de fotogramas a unos 5~6 fps e hizo que mi juego fuera injugable. ## GDScript vs
  C++ En ese momento, solo tenía unas pocas horas para entregar mi proyecto a tiempo,
  ya que perderme el Día de San Valentín significaría que tendría que esperar un año
  para entregar el proyecto y también que no tendría nada mío para regalar. Así que
  hice una solución donde tocaba notas muy cortas de mi sintetizador y luego usaría
  reverberaciones expansivas y retrasos largos para simular sonidos más largos. Esto
  me dio un rendimiento aceptable para mi proyecto, pero me dejó una inquietud en
  la mente, la idea central de generar sonidos de forma procedural era muy buena y
  funcionaba muy bien para el ambiente del juego, y sabía que esta era la forma en
  que quería componer música para mis próximos juegos. Así que comencé a investigar
  cómo optimizar el sistema de sonido que había creado inicialmente y la respuesta
  obvia fue implementarlo como un plugin GDExtension. Según DeepSeek, trasladar mi
  algoritmo de generación de sonido a C++ podría generar una mejora de 100 veces en
  el rendimiento, así que decidí hacerlo. ## Plaits Para ser completamente honesto,
  esta tampoco era la primera vez que intentaba algo así, me encanta usar VCV Rack
  y lo consideraría mi DAW principal. Soy un gran fan de la serie de plugins de audio
  SurgeXT, y su implementación en VCV es simplemente sobresaliente. SurgeXT proporciona
  amplias capacidades de modulación con ayudas visuales muy fáciles de seguir para
  mostrar lo que la modulación realmente está haciendo. También soy un gran admirador
  de Emilie Gillet y sus contribuciones de código abierto a la música electrónica,
  no creo que esté exagerando cuando digo que probablemente sea la desarrolladora
  de audio más influyente de nuestra generación. Esto me lleva a [Plaits](https://pichenettes.github.io/mutable-instruments-documentation/modules/plaits/downloads/plaits_quickstart.pdf).
  > Plaits es una fuente de sonido digital controlada por voltaje, capaz de dieciséis
  técnicas de síntesis diferentes. Plaits reclama la tierra entre todas las islas
  fragmentadas de sonido producidas por su predecesor, Braids Para aquellos de ustedes
  que no lo sepan, Plaits es un módulo de sonido macro oscilador de Mutable Instruments
  con varios motores de sonido diferentes y 4 grandes perillas en la parte frontal
  para controlar: - Frecuencia - Armónicos - Timbre - Morf Y con estos 4 simples controladores,
  el módulo es capaz de domar algunos algoritmos de oscilación que suelen ser muy
  difíciles de manejar, como la síntesis granular formante o FM. Esto les da a los
  usuarios una inmensa paleta de sonido y hace que el módulo sea extremadamente flexible,
  permitiendo a los usuarios hacer percusiones, leads, pads acordes y mucho más con
  una configuración simple pero eficiente. ## Primer intento El [código fuente](https://github.com/pichenettes/eurorack/tree/master/plaits)
  también tiene licencia MIT, así que mi primera idea fue simplemente llevar Plaits
  a Godot. Así que, en noviembre, creé un repositorio y lo llamé Glaits, vi un montón
  de tutoriales sobre cómo crear extensiones de C++ para Godot y llegué al punto en
  que podía compilar el proyecto con los submodulos de Plaits importados, pero estos
  nunca fueron pensados para ejecutarse en el mismo entorno que un motor de juego.
  Estos también eran algoritmos extremadamente optimizados, lo que significaba que
  algunos pasos críticos del código estaban escritos en ensamblador, lo que el compilador
  de Godot estaba teniendo muchos problemas para descifrar. Esto puso un freno instantáneo
  en mi proyecto justo después de una semana de desarrollo y decidí dejarlo ahí. ##
  Segundo intento Después de tomarme un descanso del intento inicial con Glaits, decidí
  abordar el problema desde un ángulo diferente. En lugar de portar directamente todo
  el módulo Plaits a Godot, me centraría en crear una versión ligera que encapsulara
  las funcionalidades principales que quería implementar en mi plugin de sintetizador.
  ### Investigación y rediseño Revisé las funcionalidades de Plaits e identifiqué
  las técnicas de síntesis clave que serían más útiles para el desarrollo de juegos.
  Estos incluyen: - **Formas de onda básicas**: Seno, Cuadrada, Diente de sierra y
  Triángulo. - **Síntesis FM**: Para contenido armónico más complejo. - **Síntesis
  granular**: Para crear texturas y paisajes sonoros evolutivos. - **Formante**: Para
  crear audio con sonido de voz. - **Generación de ruido**: Útil para sonidos y efectos
  de percusión. Con estos elementos en mente, diseñé una arquitectura simplificada
  para mi plugin de sintetizador. Esto consistiría en componentes modulares que podrían
  combinarse y controlarse fácilmente en tiempo real a través del sistema de scripting
  de Godot. ### Pasos de implementación 1. **Configuración del marco GDExtension**:
  - Creé un nuevo proyecto GDExtension dentro de Godot 4.x. - Seguí las pautas sobre
  la configuración de los enlaces de C++ para exponer mis funciones de sintetizador
  a GDScript. 2. **Desarrollo del motor de sonido central**: - Implementé formas de
  onda básicas usando C++, asegurando que estuvieran optimizadas para el rendimiento.
  - Desarrollé un módulo de síntesis FM, que permite a los usuarios ajustar los parámetros
  de modulación de frecuencia de forma dinámica. - Creé un motor de formantes para
  la síntesis de voz. 3. **Sistema de modulación**: - Añadí opciones de modulación
  para los parámetros más importantes. 4. **Componentes de la interfaz de usuario**:
  - Integré componentes de interfaz de usuario personalizados en Godot que permiten
  a los usuarios interactuar con el sintetizador fácilmente. - Utilicé nodos Control
  para crear sliders, knobs y botones que representan cada parámetro del motor de
  sonido. 5. **Pruebas y optimización**: - Realicé pruebas exhaustivas en varios dispositivos
  (incluidos los teléfonos Android de gama baja) para garantizar que el rendimiento
  se mantuviera alto incluso con múltiples instancias ejecutándose simultáneamente.
  ### Resultados iniciales Después de una semana de desarrollo utilizando herramientas
  de desarrollo impulsadas por IA, había avanzado mucho y tenía una configuración
  con 3 motores de oscilador con diferentes parámetros de modulación y soporte para
  guardar presets utilizando un recurso personalizado de Configuración de sonido.
  En esta iteración temprana e ingenua, la configuración de sonido estaba a cargo
  de casi todo, ya que crearía un motor apropiado para producir el sonido, crearía
  el bus de audio específicamente para este sonido, crearía los efectos de audio definidos
  en el array de efectos de audio. Las modulaciones también estaban codificadas en
  las variables que estaban controlando, lo que comenzó a mostrar algunos problemas
  de sincronización cuando algunas modulaciones se ejecutaban a un ritmo más rápido
  que otras. ### Problemas de buffer La gota que colmó el vaso fue al intentar crear
  un efecto modulado. Como expliqué, los efectos eran manejados por el propio bus
  de audio, lo que significaba que audio server interno de Godot estaba a cargo de
  los tiempos y el buffer, lo que creó algunos problemas con mi plan. Principalmente,
  mis modulaciones a los generadores de sonido se aplicaron sobre una base de **por
  muestra**, lo que garantizaba una alta resolución en los moduladores, pero solo
  podía modular los efectos sobre una base de **por buffer**, lo que provocaba algunos
  artefactos de sonido inesperados e incluso más desincronización. En este punto,
  incluso con todo el progreso que había hecho, me sentía desesperanzado con mi proyecto
  hasta que tuve la idea del contexto de la nota. ## Contexto de la nota La idea era
  simple: pasar una estructura de datos de contexto que el usuario pudiera usar para
  manipular la generación de sonido sin controlar directamente los motores. Contiene
  datos sobre la frecuencia actual, la velocidad y también realiza un seguimiento
  de la duración actual de la nota. Esta misma estructura ligera se pasa luego a los
  osciladores, las fuentes de modulación y los efectos para obtener buffers de audio
  actualizado. Este nuevo enfoque era muy prometedor pero requería una reelaboración
  completa de mi sistema, así que eliminé todo y comencé de nuevo desde cero. Comenzar
  de esta manera también permitió la creación del parámetro modulado, que puede definir
  un valor base flotante que puede ser modulado por cualquier fuente. Y con este último
  elemento, el núcleo de mi sintetizador estaba completo. ## Conclusión Desarrollar
  este proyecto fue una aventura muy gratificante e interesante. Me empujó a mis propios
  límites de lo que sabía sobre C++, me obligó a aprender nuevas herramientas y frameworks,
  y me desafió a terminar y publicar algo. Esta publicación ya es bastante larga,
  haré otras publicaciones más adelante explicando la arquitectura y las opciones
  tomadas con más detalle y también comenzaré un pequeño tutorial sobre cómo usar
  eficazmente LLM con Godot.

  '
First Public Release of the Godot Synth Plugin: 'Primera versión pública del plugin
  Godot Synth

  '
First public release of the Godot Synth Plugin: 'Primera versión pública del plugin
  Godot Synth

  '
Godot Synth Release: 'Lanzamiento de Sintetizador Godot

  '
'[Brand new website](https://eclipsinglines.github.io/), sharing my code for games, tools and research.': '[Sitio
  web nuevo](https://eclipsinglines.github.io/), donde comparto mi código para juegos,
  herramientas e investigación.

  '

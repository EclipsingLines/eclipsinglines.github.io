<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://eclipsinglines.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://eclipsinglines.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-20T18:00:47+00:00</updated><id>https://eclipsinglines.github.io/feed.xml</id><title type="html">blank</title><subtitle>The new lines we draw around ourselves hide the lines that used to define us. </subtitle><entry><title type="html">Godot Synth Release</title><link href="https://eclipsinglines.github.io/blog/2025/Synth-Release/" rel="alternate" type="text/html" title="Godot Synth Release"/><published>2025-03-19T00:00:00+00:00</published><updated>2025-03-19T00:00:00+00:00</updated><id>https://eclipsinglines.github.io/blog/2025/Synth-Release</id><content type="html" xml:base="https://eclipsinglines.github.io/blog/2025/Synth-Release/"><![CDATA[<h2 id="overview">Overview</h2> <p>A few days ago I finished the first version of my synthesizer plugin for Godot. This project is meant now to become a full set of features for game developers and sound designers to create, modify, modulate and perform sounds in game in a programmer friendly and efficient way.</p> <h2 id="project-start">Project Start</h2> <p>For valentine’s day in 2025 I decided to make my partner an app. She’s always liked flowers, so I made a small Godot mobile game where you procedurally grow a flower, the game has a simple day/night cycle and a procedural music system.</p> <p>And if you think that I have used the word procedural too many times, it is because I wanted to make all the content for her app during runtime.</p> <p>So I made a few algorithms, learned how to use LLMs for game development (a process which is still ongoing) and made an android build to test.</p> <p>To my surprise, the flower looked kinda nice from my very first attempt and the whole system seemed to run at a very respectable frame rate (for a GDScript running on an old Pixel phone) until the first procedurally generated music note started playing, which dropped my frame rate to about 5~6 fps and made my game unplayable.</p> <h2 id="gdscript-vs-c">GDScript vs C++</h2> <p>At that point I only had a few hours to deliver my project in time, as missing Valentine’s Day would mean I should wait a year to deliver the project and also that I would have nothing of mine to give.</p> <p>So I hacked a solution where I played very small short notes from my synth and then would use expansive reverbs and long delays to fake longer sounds.</p> <p>This got me to an acceptable performance for my project but left an itch at the back of my mind, the core idea of procedurally generating the sounds was very good and worked really well for the game ambiance, and I knew that this was the way I wanted to compose music for my next games.</p> <p>So I started looking into how to optimize the sound system I had made initially and the obvious answer was implementing it as a GDExtension plugin.</p> <p>According to DeepSeek, moving my sound generation algorithm to C++ could make a 100x improvement in performance, so I decided to do it.</p> <h2 id="plaits">Plaits</h2> <p>To be completely honest, this was not the first time I tried something like this either, I love using VCV Rack and would consider it my main DAW. I am a big fan of the SurgeXT series of audio plugins, and their implementation in VCV is just outstanding.</p> <p>SurgeXT provides extensive modulation capabilities with very easy to follow visual aids to showcase what the modulation is actually doing.</p> <p>I am also a big fan of Emilie Gillet and her open source contributions to electronic music, I don’t think I am exaggerating when I say that she’s probably the most influential audio developer of our generation. This brings me to <a href="https://pichenettes.github.io/mutable-instruments-documentation/modules/plaits/downloads/plaits_quickstart.pdf">Plaits</a>.</p> <blockquote> <p>Plaits is a digital voltage-controlled sound source capable of sixteen different synthesis techniques. Plaits reclaims the land between all the fragmented islands of sound produced by its predecessor, Braids</p> </blockquote> <p>For those of you who don’t know, Plaits is a macro oscillator sound module by Mutable Instruments with several different sound engines and 4 large knobs on the front to control:</p> <ul> <li>Frequency</li> <li>Harmonics</li> <li>Timbre</li> <li>Morph</li> </ul> <p>And with these 4 simple controllers, the module is able to tame some oscillation algorithms that are usually very difficult to manage, like granular formant or FM synthesis.</p> <p>This gives users an immense sound palette and makes the module extremely flexible, allowing users to do percussions, leads, pads chords and a lot more with a simple but efficient setup.</p> <h2 id="first-attempt">First attempt</h2> <p>The <a href="https://github.com/pichenettes/eurorack/tree/master/plaits">source code</a> for it is also MIT license, so my first idea was to simply bring Plaits into Godot.</p> <p>So back in November, I made a repository and named it Glaits, watched a bunch of tutorials on how to create C++ extensions for Godot and got up to the point where I could compile the project with the imported Plaits submodules, but these were never meant to run on the same environment as a game engine.</p> <p>These were also extremely heavily optimized algorithms, which meant that some critical steps of the code were actually written in assembler, which the Godot compiler was having a lot of trouble figuring out.</p> <p>This put a instant brake into my project just after a week of development and I decided to leave it there.</p> <h2 id="second-attempt">Second Attempt</h2> <p>After taking a break from the initial attempt with Glaits, I decided to approach the problem from a different angle. Instead of directly porting the entire Plaits module into Godot, I would focus on creating a lightweight version that encapsulated the core functionalities I wanted to implement in my synthesizer plugin.</p> <h3 id="research-and-redesign">Research and Redesign</h3> <p>I revisited the functionalities of Plaits and identified the key synthesis techniques that would be most useful for game development. These included:</p> <ul> <li><strong>Basic Waveforms</strong>: Sine, Square, Sawtooth, and Triangle.</li> <li><strong>FM Synthesis</strong>: For more complex harmonic content.</li> <li><strong>Granular Synthesis</strong>: To create evolving textures and soundscapes.</li> <li><strong>Formant</strong>: To create speech sounding audio.</li> <li><strong>Noise Generation</strong>: Useful for percussive sounds and effects.</li> </ul> <p>With these elements in mind, I designed a simplified architecture for my synthesizer plugin. This would consist of modular components that could be easily combined and controlled in real-time through Godot’s scripting system.</p> <h3 id="implementation-steps">Implementation Steps</h3> <ol> <li><strong>Setting Up the GDExtension Framework</strong>: <ul> <li>I created a new GDExtension project within Godot 4.x.</li> <li>Followed guidelines on setting up C++ bindings to expose my synthesizer functions to GDScript.</li> </ul> </li> <li><strong>Core Sound Engine Development</strong>: <ul> <li>Implemented basic waveforms using C++, ensuring they were optimized for performance.</li> <li>Developed an FM synthesis module, allowing users to adjust frequency modulation parameters dynamically.</li> <li>Created a formant engine for voice synthesis.</li> </ul> </li> <li><strong>Modulation System</strong>: <ul> <li>Added modulation options for the most important parameters.</li> </ul> </li> <li><strong>User Interface Components</strong>: <ul> <li>Integrated custom UI components in Godot that allow users to interact with the synthesizer easily.</li> <li>Used Control nodes to create sliders, knobs, and buttons representing each parameter of the sound engine.</li> </ul> </li> <li><strong>Testing and Optimization</strong>: <ul> <li>Conducted extensive testing on various devices (including lower-end Android phones) to ensure performance remained high even with multiple instances running simultaneously.</li> </ul> </li> </ol> <h3 id="early-results">Early Results</h3> <p>After a week of development on this using AI powered development tools I had made a lot of progress and had a setup with 3 oscillator engines with different modulation parameters and support for saving presets by using a Sound Configuration custom resource.</p> <p>In this early and naive iteration the sound configuration was in charge of almost everything, as it would create an appropriate engine to produce the sound, create the audio bus specifically for this sound, create the audio effects defined in the audio effect array.</p> <p>The modulations were also hardcoded into the variables they were controlling which started showing some synchronization issues when some modulations were running at a faster pace than others.</p> <h3 id="buffer-issues">Buffer issues</h3> <p>The last straw came when trying to create a modulated effect. Like I explained the effects were handled by the audio bus itself, which meant that the Godot internal audio server was in charge of the timings and the buffer which created a few issues with my plan.</p> <p>Mainly, my modulations to the sound generators were applied on a <strong>per-sample</strong> basis, ensuring high resolution on the modulators, but I could only modulate the effects on a <strong>per-buffer</strong> basis, causing some unexpected sound artifacts and even more desynchronization.</p> <p>At this point, even with all the progress I had made, I was feeling hopeless about my project until I had the idea of the note context.</p> <h2 id="note-context">Note context</h2> <p>The idea was simple: to pass a context data structure that the user could use to manipulate the sound generation without directly controlling the engines.</p> <p>It contains data about the current frequency, velocity and also keeps track of the current note duration.</p> <p>This same lightweight structure then gets passed around the oscillators, modulation sources and effects in order to obtain updated audio buffers.</p> <p>This new approach was very promising but required a complete rework of my system, so I deleted everything and started again from scratch.</p> <p>Starting this way also allowed for the creation of the modulated parameter, which can define a float base value that can be modulated by any source.</p> <p>And with this last element the core of my synthesizer was complete.</p> <h2 id="conclusion">Conclusion</h2> <p>Developing this project was a very rewarding and interesting adventure. It pushed me to my own limits of what I knew about C++, forced me to learn new tools and frameworks, and challenged me to actually finish and publish something.</p> <p>This post is long enough as it is right now, I’ll make some more other post later explaining the architecture and the choices made in more detail and will also start a small tutorial on how to effectively use LLMs with Godot.</p>]]></content><author><name></name></author><category term="Godot"/><category term="godot"/><category term="music"/><category term="c++"/><summary type="html"><![CDATA[First public release of the Godot Synth Plugin]]></summary></entry><entry><title type="html">Godot Synth Release</title><link href="https://eclipsinglines.github.io/blog/2025/Synth-Release-es/" rel="alternate" type="text/html" title="Godot Synth Release"/><published>2025-03-19T00:00:00+00:00</published><updated>2025-03-19T00:00:00+00:00</updated><id>https://eclipsinglines.github.io/blog/2025/Synth-Release-es</id><content type="html" xml:base="https://eclipsinglines.github.io/blog/2025/Synth-Release-es/"><![CDATA[<h2 id="resumen">Resumen</h2> <p>Hace unos días terminé la primera versión de mi plugin de sintetizador para Godot. Este proyecto está destinado ahora a convertirse en un conjunto completo de características para que los desarrolladores de juegos y diseñadores de sonido creen, modifiquen, modulen e interpreten sonidos en el juego de una manera eficiente y amigable para los programadores.</p> <h2 id="inicio-del-proyecto">Inicio del Proyecto</h2> <p>Para el día de San Valentín de 2025, decidí hacerle una aplicación a mi pareja. Siempre le han gustado las flores, así que hice un pequeño juego móvil de Godot donde se cultiva una flor de forma procedural, el juego tiene un simple ciclo día/noche y un sistema de música procedural.</p> <p>Y si piensas que he usado la palabra procedural demasiadas veces, es porque quería hacer todo el contenido para su aplicación durante el tiempo de ejecución.</p> <p>Así que hice algunos algoritmos, aprendí a usar LLMs para el desarrollo de juegos (un proceso que aún está en curso) e hice una compilación de Android para probar.</p> <p>Para mi sorpresa, la flor se veía bastante bien desde mi primer intento y todo el sistema parecía funcionar a una velocidad de fotogramas muy respetable (para un GDScript que se ejecuta en un viejo teléfono Pixel) hasta que comenzó a sonar la primera nota musical generada proceduralmente, lo que redujo mi velocidad de fotogramas a alrededor de 5 ~ 6 fps e imposibilitó jugar mi juego.</p> <h2 id="gdscript-vs-c">GDScript vs C++</h2> <p>En ese momento, solo me quedaban unas pocas horas para entregar mi proyecto a tiempo, ya que perderme el Día de San Valentín significaría que tendría que esperar un año para entregar el proyecto y también que no tendría nada mío para regalar.</p> <p>Así que hackeé una solución donde tocaba notas muy pequeñas de mi sintetizador y luego usaba reverbs expansivas y delays largos para fingir sonidos más largos.</p> <p>Esto me llevó a un rendimiento aceptable para mi proyecto, pero dejó una inquietud en mi mente, la idea central de generar sonidos de forma procedural era muy buena y funcionaba realmente bien para el ambiente del juego, y sabía que esta era la forma en que quería componer música para mis próximos juegos.</p> <p>Así que empecé a investigar cómo optimizar el sistema de sonido que había hecho inicialmente y la respuesta obvia fue implementarlo como un plugin de GDExtension.</p> <p>Según DeepSeek, mover mi algoritmo de generación de sonido a C++ podría mejorar el rendimiento en 100 veces, así que decidí hacerlo.</p> <h2 id="plaits">Plaits</h2> <p>Para ser completamente honesto, esta tampoco era la primera vez que intentaba algo así, me encanta usar VCV Rack y lo consideraría mi DAW principal. Soy un gran fan de la serie de plugins de audio SurgeXT, y su implementación en VCV es simplemente excepcional.</p> <p>SurgeXT proporciona amplias capacidades de modulación con ayudas visuales muy fáciles de seguir para mostrar lo que realmente está haciendo la modulación.</p> <p>También soy un gran fan de Emilie Gillet y sus contribuciones de código abierto a la música electrónica, no creo que esté exagerando cuando digo que probablemente sea la desarrolladora de audio más influyente de nuestra generación. Esto me lleva a <a href="https://pichenettes.github.io/mutable-instruments-documentation/modules/plaits/downloads/plaits_quickstart.pdf">Plaits</a>.</p> <blockquote> <p>Plaits es una fuente de sonido digital controlada por voltaje capaz de dieciséis técnicas de síntesis diferentes. Plaits reclama la tierra entre todas las islas fragmentadas de sonido producidas por su predecesor, Braids.</p> </blockquote> <p>Para aquellos que no lo sepan, Plaits es un módulo de sonido de macro oscilador de Mutable Instruments con varios motores de sonido diferentes y 4 perillas grandes en la parte frontal para controlar:</p> <ul> <li>Frecuencia</li> <li>Armónicos</li> <li>Timbre</li> <li>Morfología</li> </ul> <p>Y con estos 4 controladores simples, el módulo es capaz de domar algunos algoritmos de oscilación que suelen ser muy difíciles de manejar, como la síntesis de formantes granulares o FM.</p> <p>Esto proporciona a los usuarios una inmensa paleta de sonido y hace que el módulo sea extremadamente flexible, lo que permite a los usuarios hacer percusiones, leads, pads, acordes y mucho más con una configuración simple pero eficiente.</p> <h2 id="primer-intento">Primer Intento</h2> <p>El <a href="https://github.com/pichenettes/eurorack/tree/master/plaits">código fuente</a> también tiene licencia MIT, así que mi primera idea fue simplemente llevar Plaits a Godot.</p> <p>Así que en noviembre, hice un repositorio y lo llamé Glaits, vi un montón de tutoriales sobre cómo crear extensiones C++ para Godot y llegué hasta el punto en que podía compilar el proyecto con los submódulos Plaits importados, pero estos nunca fueron pensados para ejecutarse en el mismo entorno que un motor de juego.</p> <p>Estos eran también algoritmos extremadamente optimizados, lo que significaba que algunos pasos críticos del código estaban escritos en ensamblador, lo que provocaba muchos problemas al compilador de Godot para entenderlos.</p> <p>Esto frenó instantáneamente mi proyecto justo después de una semana de desarrollo y decidí dejarlo ahí.</p> <h2 id="segundo-intento">Segundo Intento</h2> <p>Después de tomarme un descanso del intento inicial con Glaits, decidí abordar el problema desde un ángulo diferente. En lugar de portar directamente todo el módulo Plaits a Godot, me centraría en crear una versión ligera que encapsulara las funcionalidades principales que quería implementar en mi plugin de sintetizador.</p> <h3 id="investigación-y-rediseño">Investigación y Rediseño</h3> <p>Revisité las funcionalidades de Plaits e identifiqué las técnicas de síntesis clave que serían más útiles para el desarrollo de juegos. Estos incluían:</p> <ul> <li><strong>Formas de Onda Básicas</strong>: Seno, Cuadrada, Diente de Sierra y Triángulo.</li> <li><strong>Síntesis FM</strong>: Para contenido armónico más complejo.</li> <li><strong>Síntesis Granular</strong>: Para crear texturas y paisajes sonoros en evolución.</li> <li><strong>Formantes</strong>: Para crear audio con sonido de habla.</li> <li><strong>Generación de Ruido</strong>: Útil para sonidos y efectos de percusión.</li> </ul> <p>Con estos elementos en mente, diseñé una arquitectura simplificada para mi plugin de sintetizador. Esto consistiría en componentes modulares que podrían combinarse y controlarse fácilmente en tiempo real a través del sistema de scripts de Godot.</p> <h3 id="pasos-de-implementación">Pasos de Implementación</h3> <ol> <li><strong>Configuración del Framework GDExtension</strong>: <ul> <li>Creé un nuevo proyecto GDExtension dentro de Godot 4.x.</li> <li>Seguí las directrices sobre cómo configurar los bindings de C++ para exponer mis funciones de sintetizador a GDScript.</li> </ul> </li> <li><strong>Desarrollo del Motor de Sonido Central</strong>: <ul> <li>Implementé formas de onda básicas usando C++, asegurándome de que estuvieran optimizadas para el rendimiento.</li> <li>Desarrollé un módulo de síntesis FM, permitiendo a los usuarios ajustar los parámetros de modulación de frecuencia dinámicamente.</li> <li>Creé un motor de formantes para la síntesis de voz.</li> </ul> </li> <li><strong>Sistema de Modulación</strong>: <ul> <li>Añadí opciones de modulación para los parámetros más importantes.</li> </ul> </li> <li><strong>Componentes de la Interfaz de Usuario</strong>: <ul> <li>Integré componentes de interfaz de usuario personalizados en Godot que permiten a los usuarios interactuar con el sintetizador fácilmente.</li> <li>Usé nodos Control para crear deslizadores, perillas y botones que representan cada parámetro del motor de sonido.</li> </ul> </li> <li><strong>Pruebas y Optimización</strong>: <ul> <li>Realicé pruebas exhaustivas en varios dispositivos (incluyendo teléfonos Android de gama baja) para asegurar que el rendimiento se mantuviera alto incluso con múltiples instancias ejecutándose simultáneamente.</li> </ul> </li> </ol> <h3 id="resultados-iniciales">Resultados Iniciales</h3> <p>Después de una semana de desarrollo en esto usando herramientas de desarrollo impulsadas por IA, había hecho un montón de progreso y tenía una configuración con 3 motores de oscilador con diferentes parámetros de modulación y soporte para guardar presets usando un recurso personalizado de Sound Configuration.</p> <p>En esta iteración temprana e ingenua, la configuración de sonido estaba a cargo de casi todo, ya que crearía un motor apropiado para producir el sonido, crearía el bus de audio específicamente para este sonido, crearía los efectos de audio definidos en la matriz de efectos de audio.</p> <p>Las modulaciones también estaban codificadas en las variables que estaban controlando, lo que comenzó a mostrar algunos problemas de sincronización cuando algunas modulaciones se ejecutaban a un ritmo más rápido que otras.</p> <h3 id="problemas-de-buffer">Problemas de Buffer</h3> <p>La gota que derramó el vaso fue al intentar crear un efecto modulado. Como expliqué, los efectos eran manejados por el propio bus de audio, lo que significaba que el servidor de audio interno de Godot estaba a cargo de los tiempos y el buffer, lo que creó algunos problemas con mi plan.</p> <p>Principalmente, mis modulaciones a los generadores de sonido se aplicaban <strong>por muestra</strong>, asegurando una alta resolución en los moduladores, pero solo podía modular los efectos <strong>por buffer</strong>, causando algunos artefactos de sonido inesperados e incluso más desincronización.</p> <p>En este punto, incluso con todo el progreso que había hecho, me sentía desesperanzado con mi proyecto hasta que tuve la idea del contexto de la nota.</p> <h2 id="contexto-de-la-nota">Contexto de la Nota</h2> <p>La idea era simple: pasar una estructura de datos de contexto que el usuario pudiera usar para manipular la generación de sonido sin controlar directamente los motores.</p> <p>Contiene datos sobre la frecuencia actual, la velocidad y también realiza un seguimiento de la duración actual de la nota.</p> <p>Esta misma estructura ligera se pasa a los osciladores, las fuentes de modulación y los efectos para obtener buffers de audio actualizados.</p> <p>Este nuevo enfoque era muy prometedor, pero requería una reelaboración completa de mi sistema, así que borré todo y volví a empezar desde cero.</p> <p>Comenzar de esta manera también permitió la creación del parámetro modulado, que puede definir un valor base float que puede ser modulado por cualquier fuente.</p> <p>Y con este último elemento, el núcleo de mi sintetizador estaba completo.</p> <h2 id="conclusión">Conclusión</h2> <p>Desarrollar este proyecto fue una aventura muy gratificante e interesante. Me empujó a mis propios límites de lo que sabía sobre C++, me obligó a aprender nuevas herramientas y frameworks, y me desafió a terminar y publicar algo.</p> <p>Esta publicación ya es bastante larga, haré algunas otras publicaciones más adelante explicando la arquitectura y las elecciones hechas con más detalle y también comenzaré un pequeño tutorial sobre cómo usar eficazmente los LLMs con Godot.</p>]]></content><author><name></name></author><category term="Godot"/><category term="godot"/><category term="music"/><category term="c++"/><summary type="html"><![CDATA[First public release of the Godot Synth Plugin]]></summary></entry></feed>